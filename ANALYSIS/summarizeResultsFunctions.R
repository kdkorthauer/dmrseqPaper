#' Evaluate power and FDR in simulation studies of DMRs
#' 
#' Plots ROC curves of sensitivity and specificity given a simulated dmr 
#' object returned by \code{simDMRs}
#' 
#' @inheritParams summarizeResults
#' 
#' @param sim.file a filename pointing to simulated object generated by
#' \code{simDMRs}
#' @param result.file.prefix character object that specifies the file 
#' 	 string for where the results plots should be saved
#' @param sampleSize number of samples per population
#' @param	OBS DMR results object returned by \code{dmrseq}
#' @param cond character label for experiment
#' @param which.sig integer vector indicating which rows of OBS are significant
#' @param METHOD character label for name of the method that produced OBS
#' @param num.to.plot numeric value for the number of top DMRs to plot
#' @param design design matrix for the comparison   
#'   
#' @return None - generates plots
#' 
#' @import ROCR       

evaluateSimulation <- function(OBS, result.file.prefix, num.dmrs, 
                               sampleSize, cond,
                               which.sig, METHOD, num.to.plot=NULL,
                               sim.file, design){
  library(ROCR)
  # load simulated bsseq obj for plotting regions
  load(sim.file) 
  # loads an object named sim.dat.red
  # with list items bs, dmr.mncov, dmr.L
  
  bs <- sim.dat.red$bs
  dmr.mncov <- sim.dat.red$dmr.mncov
  dmr.L <- sim.dat.red$dmr.L
  dmrs.true <- sim.dat.red$gr.dmrs
  rm(sim.dat.red)
  
  # set up colors to represent the covariate of interest
  if (length(unique(design[,coeff])) > 2){
    # if this is a multi-group comparison or continuous covariate,
    # use the rainbow function to define a range of colors in the 
    # order of the rank of the covariate
    age.unique <- unique(design[,coeff])
    colors <- rainbow(length(age.unique))
    # assign a unique color to each age (in age order)
    colors <- cbind(age.unique, colors[rank(age.unique)])
    # map each row of the design matrix to a color
    z <- colors[,2][match(design[,coeff], colors[,1])]
    pData(bs)$col <- as.character(z)
    
  }else{ 
    # if this is a 2-group comparison, use red and blue
    colors <- c("red", "blue")
    colors <- cbind( c(0,1), colors)
    
    # map each row of the design matrix to a color
    z <- colors[,2][match(design[,coeff], colors[,1])]
    pData(bs)$col <- as.character(z)
    
    # search for tissue/condition names in relevant design matrix column
    # doesn't assume pData already contains the condition labels
    t1 <- grep(tiss1, colnames(design)[coeff])
    t2 <- grep(tiss2, colnames(design)[coeff])
    
    # 0 = red, 1 = blue
    if (length(t1) > 0){
      pData(bs)$label <- tiss2
      pData(bs)$label[pData(bs)$col == "blue"] <- tiss1
    }else if(length(t2) > 0){
      pData(bs)$label <- tiss1
      pData(bs)$label[pData(bs)$col == "blue"] <- tiss2
    }
    
  }	
  
  # compute power and FDR for each method
  if (length(which.sig) > 0){
    dmrs <- OBS[which.sig,]
    dmrs <- dmrs[order(-abs(dmrs$stat)),]
    not.dmrs = dmrs.true[countOverlaps(dmrs.true, 
                                       makeGRangesFromDataFrame(dmrs))==0]
    
    FDR <- round(sum(countOverlaps(makeGRangesFromDataFrame(dmrs), 
                                   dmrs.true)==0)/nrow(dmrs),3)
    Power <- round(sum(countOverlaps(dmrs.true, 
                                     makeGRangesFromDataFrame(dmrs))>0)/
                     length(dmrs.true), 3)
    print(Power)
    print(FDR)
    
    # to plot ROC curves need to add the simulated dmrs that were not detected
    # and indicate that they were all ranked the lowest 	
    allRegions <- matrix(0, nrow=length(not.dmrs), ncol=ncol(dmrs))
    colnames(allRegions) <- colnames(dmrs)
    allRegions <- as.data.frame(allRegions)
    allRegions$chr <- as.character(seqnames(not.dmrs))
    allRegions$start <- start(not.dmrs)
    allRegions$end <- end(not.dmrs)
    
    allRegions <- rbind(dmrs, allRegions)
    
    hit <- countOverlaps(dmrs.true, makeGRangesFromDataFrame(dmrs)) > 0	
    hit2 <- countOverlaps(makeGRangesFromDataFrame(allRegions), dmrs.true) > 0
    pred <- prediction(abs(allRegions$stat), hit2)
    perf <- performance(pred, "tpr", "fpr")
    
    # plot ROC curve for detected dmrs
    pdf(file=paste0(result.file.prefix, "/SimResults.n", sampleSize, ".",
                    cond, ".", 
                    num.dmrs, "DMRs.", METHOD, ".sim.pdf"))	
    
    plot(perf, col="blue", lty=2, main=paste0(Power*100,
                                              " percent of DMRs were detected"),
         lwd=2, xlim=c(0,0.2))
    
    num.down <- sum(OBS$stat[which.sig] < 0, na.rm=TRUE)  	
    par(mfrow=c(1,1));
    plot(0,0, col="white", yaxt="n", xaxt="n",  ylab="", xlab="", bty="n")
    text(0,0, paste0("Significant regions: ", length(which.sig),
                     "\n", "Power (FDR): ", Power, " (", FDR, ")",
                     "\n","Proportion demethylated: ", 
                     round(num.down/length(which.sig), 3)))
    dev.off()
    
    
    # plot significant regions  and color by which regions are true
    # DMRs or not 
    # limit to 'num.to.plot' regions if this is specified
    if (is.null(num.to.plot)){
      num.to.plot <- nrow(dmrs)
    }
    
    if (num.to.plot < nrow(dmrs)){
      dmrs.red <- dmrs[1:min(num.to.plot, nrow(dmrs)),] 
    }else{
      dmrs.red <- dmrs
    }
    
    colnames(dmrs.red)[c(4,5)] <- c("indexStart", "indexEnd")
    
    
  }else{
    message("No Significant regions found")
    # if no significant regions are found then all of the true dmrs
    # were missed; 
    # plot these 
    not.dmrs = dmrs.true		
    pdf(file=paste0(result.file.prefix, "/SimDMRsMissed.n", 
                    sampleSize, ".", cond, ".", 
                    num.dmrs, "DMRs.", METHOD, ".sim.pdf"), 
        height=4, width=8)		
    plotDMRs(bs, regions=not.dmrs, 
             extend=(end(not.dmrs)-start(not.dmrs)+1)/2, 
             addRegions=dmrs.true,
             addPoints=TRUE, pointsMinCov=1,
             qval=FALSE, stat=FALSE)
    dev.off()
  }
}

# try different cutoffs and save #Detected, power, and fdr
# in a txt file table
tryDifferentCutoffs <- function(LOCI, minNumRegion,
                                cutoffsQ=c(0.00001,0.0001,0.0005,
                                           0.005,0.01,0.025,0.05,0.1,0.2),
                                result.file.prefix, num.dmrs, sampleSize, cond,
                                METHOD, sim.file, maxGap){
  
  load(sim.file) 
  # loads an object named sim.dat.red
  # with list items bs, dmr.mncov, dmr.L
  
  dmrs.true <- sim.dat.red$gr.dmrs
  rm(sim.dat.red)
  
  if(METHOD=="DSS"){
    addQ <- sum(LOCI$pval < 1e-5)/nrow(LOCI)
    cutoffsQ <- sort(c(cutoffsQ, addQ))
  }
  
  res <- data.frame(nDMR=rep(NA, length(cutoffsQ)),
                    power=rep(NA, length(cutoffsQ)),
                    fdr=rep(NA, length(cutoffsQ)),
                    nHitsTrue=rep(NA, length(cutoffsQ)),
                    falseLength=rep(NA, length(cutoffsQ)))
  rownames(res) <- cutoffsQ
  
  for(q in 1:length(cutoffsQ)){
    
    if (METHOD=="BSmooth"){
      dmrs0 <- dmrFinder(LOCI, qcutoff=sort(c(cutoffsQ[q], 1-cutoffsQ[q])),
                         stat="tstat", maxGap=maxGap)
      dmrs <- subset(dmrs0, n >= minNumRegion)
      dmrs$stat <- dmrs$areaStat/dmrs$n
    }
    
    if (METHOD=="DSS"){
      cutoffsQ[q] <- min(cutoffsQ[q], 1-cutoffsQ[q])
      # which pvalue cutoff corresponds to this quantile cutoff
      pthresh <- quantile(LOCI$pval, cutoffsQ[q])
      if (pthresh > 0){
        dmrs <- callDMR(LOCI, p.threshold=pthresh, minCG=minNumRegion-1)	
        dmrs$stat <- dmrs$areaStat/dmrs$nCG
      }else{
        dmrs <- data.frame()
      }
    }
    
    if (METHOD=="dmrseq" | METHOD=="metilene"){
      dmrs <- LOCI[LOCI$qval <= cutoffsQ[q] & !is.na(LOCI$qval),]
      
    }
    
    
    if (nrow(dmrs)>0){
      res$fdr[q] <- round(sum(countOverlaps(makeGRangesFromDataFrame(dmrs), 
                                            dmrs.true)==0)/nrow(dmrs),3)
      res$power[q] <- round(sum(countOverlaps(dmrs.true, 
                                              makeGRangesFromDataFrame(dmrs))>0)/
                              length(dmrs.true), 3)
      res$nDMR[q] <- nrow(dmrs)
      res$falseLength[q] <- sum(dmrs$end-dmrs$start + 1)
      
      if (res$power[q] > 0){
        res$nHitsTrue[q] <- round( 
          sum(countOverlaps(makeGRangesFromDataFrame(dmrs), dmrs.true)) / 
            sum(countOverlaps(dmrs.true, makeGRangesFromDataFrame(dmrs))>0), 3)
      }
    }else{
      res$power[q] <- 0
      res$nDMR[q] <- 0
    }
    message(paste0("cutoff ", q, " checked"))
    #message(pthresh)
  }
  write.table(res, file=paste0(result.file.prefix, "/PowerFDRtable.n", 
                               sampleSize, ".", cond, ".", 
                               num.dmrs, "DMRs.", METHOD, ".sim.txt"),
              quote=FALSE, sep="\t")
}

#' @title Compare two sets of DMR results
#' 
#' @description Computes how many regions were found in each set of results, and
#' how many regions overlap. Will also plot the top regions in each 
#' set that do not overlap with any regions in the other (exclusive regions).
#' 
#' @details Special situations:
#' 
#' 1. one of the sets contains no significant regions - no region plots needed;
#'		will already have plots of significant and top nonsignificant regions 
#'		
#' 2. both of the sets contains no significant regions - look at the overlap 
#' 		between the top \code{num.to.plot} ranked regions 
#' 		(even though not significant), 
#' 		and then plot the regions that are exclusive to each list
#' 		
#' @inheritParams summarizeResults
#' @param bs BSseq object
#' @param dmr1 the DMR results object for the first method/scenario
#' @param dmr2 the DMR results object for the second method/scenario
#' @param which.sig1 a vector of integers that represent which rows of dmr1 are 
#'		significant regions  
#' @param which.sig2 a vector of integers that represent which rows of dmr2 are
#'		significant regions
#' @param LIST1 character object containing the name of the experiment 
#' 		that generated results in the first dmr object dmr1
#' @param LIST2 character object containing the name of the experiment that 
#' 		generated results in the second dmr object dmr2
#' @param genomeName a character object that indicates which organism is 
#' under study. Use the function \code{annotatr:::builtin_genomes()} to see
#' a character vector of available genome names to choose from (see 
#' \code{annotatr} documentation for more details).
#' @param num.to.plot an integer value representing the number of 
#' regions to plot.
#'  	 If this is not specified, or if there are fewer regions in which.sig than
#' 	 	 all regions corresponding to which.sig are plotted.  
#' 	 	 If num.to.plot is less
#' 		 than the length of which.sig, then the num.to.plot regions with the most 
#'		 extreme Stat are plotted 
#'	@param testCovariate integer value or vector indicating which of columns of
#'  \code{pData(bs)} contains the covariate of interest that will be tested 
#'  for association of methylation levels. This is used to construct the 
#'  design matrix for the test statistic calculation.
#' @param adjustCovariate an (optional) integer value or vector indicating
#'  which of the columns of \code{pData(bs)} will be adjusted for when 
#'  testing for the association of methylation value with the 
#'  \code{testCovariate}. If not NULL (default), then this is also used to 
#'  construct the design matrix for the test statistic calculation.

compareOverlap <- function(dmr1, dmr2, 
                           which.sig1=1:nrow(dmr1), which.sig2=1:nrow(dmr2), 
                           num.to.plot=NULL,
                           bs, LIST1, LIST2,
                           result.file.prefix, sampleSize, cond,
                           testCovariate, adjustCovariate=NULL, 
                           genomeName=NULL){
  
 # convert covariates to column numbers if characters
  if (is.character(testCovariate)){
    tc <- testCovariate
    testCovariate <- which(colnames(pData(bs)) == testCovariate)
    if (length(testCovariate)==0){
      stop(paste0("testCovariate named ", tc, 
                  " not found in pData(). ", 
                  "Please specify a valid testCovariate"))
    }
    rm(tc)
  }
  
  # construct the design matrix using the pData of bs
  if (ncol(pData(bs)) < max(testCovariate, adjustCovariate)){
    stop(paste0("Error: pData(bs) has too few columns.  Please specify valid ",
                "covariates to use in the analysis"))
  }
  
  coeff <- 2:(2+length(testCovariate)-1)
  testCov <- pData(bs)[,testCovariate]
  if (length(unique(testCov))==1){
    message(paste0("Warning: only one unique value of the specified ",
                   "covariate of interest.  Assuming null comparison and ",
                   "splitting sample group into two equal groups"))
    testCov <- rep(1, length(testCov))
    testCov[1:round(length(testCov)/2)] <- 0
  }
  if (!is.null(adjustCovariate)){
    adjustCov <- pData(bs)[,adjustCovariate]
    design <- model.matrix( ~ testCov + adjustCov)
    colnames(design)[coeff] <- colnames(pData(bs))[testCovariate]
    colnames(design)[,(max(coeff)+1):ncol(design)] <- 
      colnames(pData(bs))[adjustCovariate]
  }else{
    design <- model.matrix( ~ testCov)
    colnames(design)[coeff] <- colnames(pData(bs))[testCovariate]
  }
  
  
  if(length(which.sig1) == 0 & length(which.sig2) > 0){
    message("No significant regions found with method 1")
    return(NULL)
  }else if(length(which.sig1) > 0 & length(which.sig2) == 0){
    message("No significant regions found with method 2")
    return(NULL)
  }
  
  if(length(which.sig1) > 0 & length(which.sig2) > 0){
    # if both have significant dmrs, then keep only the significant regions
    dmr1 <- dmr1[which.sig1,]
    dmr2 <- dmr2[which.sig2,]
    
  }else{ # only case left is that neither method has any significant DMRs
    # compare top ranked regions in both (up to num.to.plot)
    stop("Error: one or more methods finds no significant DMRs")
  }
  
  orderBy <- c("beta", "stat")
  
  for(ord in orderBy){
    
  # compute overlap between the two objects and construct 'exclusive' objects
  # containing only regions found exclusively by each method
  dmr1.excl <- dmr1[-queryHits(findOverlaps(makeGRangesFromDataFrame(dmr1),
                                            makeGRangesFromDataFrame(dmr2))),]
  dmr2.excl <- dmr2[-queryHits(findOverlaps(makeGRangesFromDataFrame(dmr2),
                                            makeGRangesFromDataFrame(dmr1))),]  	
  
  if (ord == "beta"){
    # order regions in both objects by their respective avg statistics
    dmr1.excl <- dmr1.excl[order(-abs(dmr1.excl$beta)),]
    dmr2.excl <- dmr2.excl[order(-abs(dmr2.excl$beta)),]
  }else{
    # order regions in both objects by their respective sum statistics
    dmr1.excl <- dmr1.excl[order(-abs(dmr1.excl$stat)),]
    dmr2.excl <- dmr2.excl[order(-abs(dmr2.excl$stat)),]
  }
  
  # keep track of how  many regions are overlapping
  cat(paste0(" ", LIST1, " finds ", length(which.sig1), " regions"), "\n",
      paste0(LIST2, " finds ", length(which.sig2), " regions"), "\n",
      paste0(LIST1, " finds ", nrow(dmr1.excl), " exclusive regions"), "\n",
      paste0(LIST2, " finds ", nrow(dmr2.excl), " exclusive regions"), "\n",
      file = paste0(result.file.prefix, "/ExclusiveDMRtotals.n", 
                    sampleSize, ".", cond, ".", LIST1, "_", LIST2, ".txt"))
  
  # only plot the top num.to.plot exclusive regions in each
  if(num.to.plot < nrow(dmr1.excl)){
    dmr1.excl.large <- dmr1.excl[dmr1.excl$L > 20, ]
    dmr1.excl.small <- dmr1.excl[dmr1.excl$L <=20, ]
    
    if (nrow(dmr1.excl.large)>0 & nrow(dmr1.excl.small)>0){
      dmr1.excl <- rbind(dmr1.excl.large[1:min(num.to.plot, nrow(dmr1.excl.large)),],
                       dmr1.excl.small[1:min(num.to.plot, nrow(dmr1.excl.small)),])
    }else{
      dmr1.excl <- dmr1.excl[1:min(num.to.plot, nrow(dmr1.excl)),]
    }
  }
  
  if(num.to.plot < nrow(dmr2.excl)){
    dmr2.excl.large <- dmr2.excl[dmr2.excl$L > 20, ]
    dmr2.excl.small <- dmr2.excl[dmr2.excl$L <=20, ]
    
    if (nrow(dmr2.excl.large)>0 & nrow(dmr2.excl.small)>0){
      dmr2.excl <- rbind(dmr2.excl.large[1:min(num.to.plot, nrow(dmr2.excl.large)),],
                          dmr2.excl.small[1:min(num.to.plot, nrow(dmr2.excl.small)),])
    }else{
      dmr2.excl <- dmr2.excl[1:min(num.to.plot, nrow(dmr2.excl)),]
    }
  }
  
  gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  
  # set up colors and sample labels for plotting 
  # one unique color per unique value of the covariate of interest
  cov.unique <- unique(design[,coeff])
  colors <- gg_color_hue(length(cov.unique))
  if (length(cov.unique) == 2){
    colors <- c("mediumblue", "deeppink1")
  }
  colors <- cbind(cov.unique, colors[rank(as.numeric(cov.unique))])
  z <- colors[,2][match(design[,coeff], colors[,1])]
  pData(bs)$col <- as.character(z)
  pData(bs)$label <- paste0(pData(bs)[,testCovariate])
  
  annot <- getAnnot(genomeName) 
  
  plotFile <- paste0(result.file.prefix, "/", LIST1, "not", LIST2, ".n", 
                     sampleSize,
                     ".", cond, "_", ord, ".pdf")
  pdf(file=plotFile, height=4, width=8)
  plotDMRs(bs, regions=dmr1.excl, 
           extend=(dmr1.excl$end - dmr1.excl$start + 1)/2, 
           addRegions=dmr1.excl, annoTrack = annot, 
           addPoints=TRUE, pointsMinCov=1, qval=FALSE,
           stat=FALSE)
  dev.off()
  
  plotFile <- paste0(result.file.prefix, "/", LIST2, "not", LIST1, ".n", 
                     sampleSize,
                     ".", cond, "_", ord, ".pdf")
  pdf(file=plotFile, height=4, width=8)
  plotDMRs(bs, regions=dmr2.excl, 
           extend=(dmr2.excl$end - dmr2.excl$start + 1)/2, 
           addRegions=dmr2.excl, annoTrack = annot,
           addPoints=TRUE, pointsMinCov=1, qval=FALSE,
           stat=FALSE)
  dev.off()
  }
} 


#' Summarize the results of DMR finding
#' 
#' Takes in a BSseq object and DMR results, and summarizes by plotting the 
#' top regions, as well as the distribution of the test statistics in the data
#' 
#' @param bs a bsseq object containing the raw methylation data and 
#' sample metadata 
#' @param OBS is the DMR results object - should contain one row for each 
#' region, 
#'   	columns named start and end that correspond to the start and 
#'   	end position of
#' 		that region, a column named Stat that contains the test statistic for the
#' 		region (should be normalized for the length of the region
#' @param which.sig a vector containing the index of the rows of OBS that
#'  represent
#' 		the regions that are deemed significant by the current method. 
#' 		 If there are 
#'		no regions that are significant, then the top num.to.plot regions 
#'		are plotted
#'  	(or top 500 if num.to.plot is not specified).
#' @param METHOD a character object that contains the name of the method 
#' (e.g. "dmrseq",
#' 		"BSmooth", or "DSS"
#' @param testCovariate integer value or vector indicating which of columns of
#'  \code{pData(bs)} contains the covariate of interest that will be tested 
#'  for association of methylation levels. This is used to construct the 
#'  design matrix for the test statistic calculation.
#' @param adjustCovariate an (optional) integer value or vector indicating
#'  which of the columns of \code{pData(bs)} will be adjusted for when 
#'  testing for the association of methylation value with the 
#'  \code{testCovariate}. If not NULL (default), then this is also used to 
#'  construct the design matrix for the test statistic calculation.
#' @param design a matrix representing the design matrix (with 
#' samples in rows and
#' 		 and covariates in columns
#' @param coeff an integer representing the number of the column of the 
#' design matrix
#'		 that represents the covariate of interest that is associated with DMRs 
#' @param num.to.plot an integer value representing the number of 
#' regions to plot.
#'  	 If this is not specified, or if there are fewer regions in which.sig than
#' 	 	 all regions corresponding to which.sig are plotted.  
#' 	 	 If num.to.plot is less
#' 		 than the length of which.sig, then the num.to.plot regions with the most 
#'		 extreme Stat are plotted 
#' @param result.file.prefix character object that contains 
#' the directory where the
#'  	results files/plots will be saved
#' @param sampleSize an integer that represents the 
#' number of samples per condition
#'  	(is equal to the total sample size divided by 2)
#' @param cond a character vector that contains the name 
#' of the condition comparison

summarizeResults <- function(bs, OBS, METHOD, which.sig, testCovariate, 
                             adjustCovariate=NULL, 
                             num.to.plot=NULL, result.file.prefix, 
                             sampleSize, cond, genomeName=NULL){	  	
  
  # convert covariates to column numbers if characters
  if (is.character(testCovariate)){
    tc <- testCovariate
    testCovariate <- which(colnames(pData(bs)) == testCovariate)
    if (length(testCovariate)==0){
      stop(paste0("testCovariate named ", tc, 
                  " not found in pData(). ", 
                  "Please specify a valid testCovariate"))
    }
    rm(tc)
  }
  
  # construct the design matrix using the pData of bs
  if (ncol(pData(bs)) < max(testCovariate, adjustCovariate)){
    stop(paste0("Error: pData(bs) has too few columns.  Please specify valid ",
                "covariates to use in the analysis"))
  }
  
  coeff <- 2:(2+length(testCovariate)-1)
  testCov <- pData(bs)[,testCovariate]
  if (length(unique(testCov))==1){
    message(paste0("Warning: only one unique value of the specified ",
                   "covariate of interest.  Assuming null comparison and ",
                   "splitting sample group into two equal groups"))
    testCov <- rep(1, length(testCov))
    testCov[1:round(length(testCov)/2)] <- 0
  }
  if (!is.null(adjustCovariate)){
    adjustCov <- pData(bs)[,adjustCovariate]
    design <- model.matrix( ~ testCov + adjustCov)
    colnames(design)[coeff] <- colnames(pData(bs))[testCovariate]
    colnames(design)[,(max(coeff)+1):ncol(design)] <- colnames(pData(bs))[adjustCovariate]
  }else{
    design <- model.matrix( ~ testCov)
    colnames(design)[coeff] <- colnames(pData(bs))[testCovariate]
  }
  
  # get median coverage for all samples
  cov.mat = getCoverage(bs, type = "Cov")
  meds <- apply(cov.mat, 2, median)
  rm(cov.mat)
  gc()
  
  # set up colors to represent the covariate of interest
  if (length(unique(design[,coeff])) > 2){
    # if this is a multi-group comparison or continuous covariate,
    # use the rainbow function to define a range of colors in the 
    # order of the rank of the covariate
    age.unique <- unique(design[,coeff])
    colors <- rainbow(length(age.unique))
    # assign a unique color to each age (in age order)
    colors <- cbind(age.unique, colors[rank(age.unique)])
    # map each row of the design matrix to a color
    z <- colors[,2][match(design[,coeff], colors[,1])]
    pData(bs)$col <- as.character(z)
    
  }else{ 
    # if this is a 2-group comparison, use red and blue
    colors <- c("red", "blue")
    colors <- cbind( c(0,1), colors)
    
    # map each row of the design matrix to a color
    z <- colors[,2][match(design[,coeff], colors[,1])]
    pData(bs)$col <- as.character(z)
    
    # search for tissue/condition names in relevant design matrix column
    # doesn't assume pData already contains the condition labels
    t1 <- grep(tiss1, colnames(design)[coeff])
    t2 <- grep(tiss2, colnames(design)[coeff])
    
    # 0 = red, 1 = blue
    if (length(t1) > 0){
      pData(bs)$label <- tiss2
      pData(bs)$label[pData(bs)$col == "blue"] <- tiss1
    }else if(length(t2) > 0){
      pData(bs)$label <- tiss1
      pData(bs)$label[pData(bs)$col == "blue"] <- tiss2
    }
    
  }
  
  # use the getAnnot function to obtain the CpG island and gene boundary
  # annotation information for the genome specified by genomeName (for plotting
  # individual regions)
  if(!is.null(genomeName)){
    annot <- getAnnot(genomeName)
  }
  
  if (length(which.sig) > 0){
    # plot the observed distribution of test statistics 	
    p1a <- ggplot() + geom_density(aes(x=stat), fill="red", 
                                   alpha=0.3, data=OBS[which.sig,]) + 
      geom_density(aes(x=stat), fill="blue", alpha=0.3, data=OBS[-which.sig,]) +
      ylab("Density") + xlab("Region Test Statistic")  +
      ggtitle("Red=DMRs, Blue=non-DMRs") + 
      theme_bw()
    
    
    # Plotting individual regions that are significant  
    # Next subset on the top regions if there are more 
    # DMRs than we'd like to plot
    if (num.to.plot < length(which.sig)){
      # First place in order of the test statistic
      OBS <- OBS[order(-abs(OBS$stat)),]
      # Next keep only the first num.to.plot regions
      plotThese <- unique(c(1:num.to.plot, 
                            (length(which.sig)-num.to.plot+1):length(which.sig)))
      OBS <- OBS[plotThese,]
    }else{
      # first subset on all significant genes
      OBS <- OBS[which.sig,]
      # next place in order of the test statistic
      OBS <- OBS[order(-abs(OBS$stat)),]
    }
  }else{
    # handle the case where there are no regions that are significant 
    # plot the observed distribution of test statistics 	
    p1a <- ggplot() + geom_density(aes(x=stat), fill="blue", 
                                   alpha=0.3, data=OBS) + 
      ylab("Density") + xlab("Region Test Statistic") +
      ggtitle("No significant DMRs found") + 
      theme_bw()
    
    if (is.null(num.to.plot)){
      num.to.plot <- 500
    }
    
    # first order regions by the test statistic
    OBS <- OBS[order(-abs(OBS$stat)),]
    # Next keep only the first num.to.plot regions
    OBS <- OBS[1:min(num.to.plot, nrow(OBS)),]
    
  }
  
  
  pdf(file=paste0(result.file.prefix, "/StatisticDistribution.n", 
                  sampleSize, ".", cond, ".",
                  METHOD, ".pdf"))
  
  print(p1a)
  
  num.down <- sum(OBS$beta[which.sig] < 0, na.rm=TRUE)
  par(mfrow=c(1,1));plot(0,0, col="white", yaxt="n", xaxt="n",  
                         ylab="", xlab="", bty="n")
  text(0,0, paste0(nrow(bs), " loci with coverage >= 1 in all samples",
                   "\n","Median coverage by sample range: ", 
                   range(meds)[1], "-", range(meds)[2],
                   "\n","Candidate regions detected: ", nrow(OBS),
                   "\n","Significant regions: ", length(which.sig),
                   "\n","Proportion demethylated: ", 
                   round(num.down/length(which.sig), 3)
  ))
  
  dev.off()
  
  if (METHOD=="BSmooth" | METHOD=="bsmooth"){
    OBS$indexStart <- OBS$idxStart
    OBS$indexEnd <- OBS$idxEnd
  }else if (METHOD == "DSS" | METHOD == "dss"){
    OBS$indexStart <- OBS$start
    OBS$indexEnd <- OBS$end
  }
  if (!file.exists(paste0(result.file.prefix, "/DMR_Plots.n", sampleSize,
                          ".", cond,
                          ".", METHOD, ".pdf"))){
    pdf(file=paste0(result.file.prefix, "/DMR_Plots.n", sampleSize,
                    ".", cond,
                    ".", METHOD, ".pdf"),
        height=4, width=8)				
    plotDMRs(bs, regions=OBS,
             extend=(OBS$end-OBS$start+1)/2, 
             addRegions=OBS, annoTrack = annot, 
             addPoints=TRUE, pointsMinCov=1, qval=FALSE)
    dev.off()
  }
}

# function to generate fdr plots and top hit region plots 
# and if simulated ROC plots as well as missed region plots
summaryPlotting <- function (regions, bs, testCovariate, sampleSize, 
                             num.dmrs, cond, 
                             pval.thresh, num.to.plot, genomeName, 
                             result.file.prefix, dmrs.true=NULL){
  
  # convert covariates to column numbers if characters
  if (is.character(testCovariate)){
    tc <- testCovariate
    testCovariate <- which(colnames(pData(bs)) == testCovariate)
    if (length(testCovariate)==0){
      stop(paste0("testCovariate named ", tc, 
                  " not found in pData(). ", 
                  "Please specify a valid testCovariate"))
    }
    rm(tc)
  }
  
  # construct the design matrix using the pData of bs
  if (ncol(pData(bs)) < max(testCovariate)){
    stop(paste0("Error: pData(bs) has too few columns.  Please specify valid ",
                "covariates to use in the analysis"))
  }
  coeff <- 2:(2+length(testCovariate)-1)
  testCov <- pData(bs)[,testCovariate]
  design <- model.matrix( ~ testCov)
  colnames(design)[coeff] <- colnames(pData(bs))[testCovariate]
  
  gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  
  # set up colors and sample labels for plotting 
  # one unique color per unique value of the covariate of interest
  cov.unique <- unique(design[,coeff])
  colors <- gg_color_hue(length(cov.unique))
  if (length(cov.unique) == 2){
    colors <- c("mediumblue", "deeppink1")
  }
  colors <- cbind(cov.unique, colors[rank(as.numeric(cov.unique))])
  z <- colors[,2][match(design[,coeff], colors[,1])]
  pData(bs)$col <- as.character(z)
  pData(bs)$label <- paste0(pData(bs)[,testCovariate])
  
  # plot local fdr results
  library("fdrtool")
  pdf(file=paste0(result.file.prefix, "/fdrtool.n", sampleSize, ".", cond, ".",
                  num.dmrs, "DMRs.pdf"), height=11)				
  fdrt <- fdrtool(regions$pval[!is.na(regions$pval)], statistic="pvalue")
  ftsig <- sum(fdrt$lfdr < pval.thresh)
  mtext(paste0("  (", ftsig, " Significant)"), side=1, cex = 1)
  dev.off()
  
  
  # region by region plots
  if(num.dmrs == 0){
    if (sum(regions$qval < pval.thresh & !is.na(regions$qval)) > 100){
      dmrs <- regions[regions$qval < pval.thresh & !is.na(regions$qval), ]
      if(nrow(dmrs) > num.to.plot){
        plotThese <- unique(c(1:num.to.plot, 
                              (nrow(dmrs)-num.to.plot+1):nrow(dmrs)))
        dmrs <- dmrs[plotThese,]
      }
    }else{
      dmrs <- regions[1:min(nrow(regions), num.to.plot),]
    }
    
    # build annotation object for plotting 
    # annotates CpG islands and Gene symbols for mm10 or hg19
    # if not one of those genomes, will input refseq ids for genes
    annot <- getAnnot(genomeName) 
    
    # plot top regions
    if (nrow(dmrs) > 0){
      plotFile <- paste0(result.file.prefix, "/dmrseq_plot.n", sampleSize,
                         ".", cond, ".pdf")
        pdf(file=plotFile, height=4, width=8)
        plotDMRs(bs, regions=dmrs, 
                 extend=(dmrs$end - dmrs$start + 1)/2, 
                 addRegions=dmrs, annoTrack = annot, 
                 addPoints=TRUE, pointsMinCov=1)
        dev.off()
    }
  }else{
    library(ROCR)
    
    FDR <- NA
    Power <- 0
    if (sum(regions$qval < pval.thresh & !is.na(regions$qval)) > 0){
      dmrs <- regions[regions$qval < pval.thresh & !is.na(regions$qval), ]
      
      FDR <- round(sum(countOverlaps(makeGRangesFromDataFrame(dmrs), 
                                     dmrs.true)==0)/nrow(dmrs),3)
      Power <- round(sum(countOverlaps(dmrs.true, 
                                       makeGRangesFromDataFrame(dmrs))>0)/
                       length(dmrs.true), 3)
      
      hit <- countOverlaps(dmrs.true, makeGRangesFromDataFrame(dmrs)) > 0	
      hit2 <- countOverlaps(makeGRangesFromDataFrame(regions), dmrs.true)>0
      pred <- prediction(1-regions$qval, hit2)
      perf <- performance(pred, "tpr", "fpr")
    }else{
      dmrs <- regions
    }
    
    message(paste0("Power: ", Power))
    message(paste0("FDR: ", FDR))
    
    # detected regions
    dmrs.toPlot <- dmrs
    if (nrow(dmrs.toPlot) > num.to.plot) {  # only plot top num.to.plot
      plotThese <- unique(c(1:num.to.plot, 
                            (nrow(dmrs.toPlot)-
                               num.to.plot+1):nrow(dmrs.toPlot)))
      dmrs.toPlot <- dmrs.toPlot[plotThese,]
    }
    pdf(file=paste0(result.file.prefix, "/dmrseq_plot.n", sampleSize, ".", 
                    cond, ".", num.dmrs, "DMRs.sim.pdf"),
        height=4, width=8)		
    plotDMRs(bs, regions=dmrs.toPlot,  
             extend=(dmrs.toPlot$end-dmrs.toPlot$start+1)/2, 
             addRegions=list(dmrs.toPlot, dmrs.true), 
             addPoints=TRUE, pointsMinCov=1)
    dev.off()    
    
  }
}
